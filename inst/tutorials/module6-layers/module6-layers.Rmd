---
title: "Data Viz Advanced: More about `ggplot` Layers"
tutorial:
  id: "module6-layers"
  name: "More about `ggplot` Layers"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
author: Justin Luningham
description: "Exercise covering additional `ggplot` layers."
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(learnr)
library(knitr)
library(tutorial.helpers)
options(repos = c(CRAN = "https://cran.rstudio.com"))
if (!requireNamespace("ggridges", quietly = TRUE)) {
  learnr::tutorial_warning(
    "This exercise uses the **ggridges** package.  
    It looks like you don’t have scales installed yet.  
    Please run this in your console:
    
    install.packages(\"ggridges\")"
  )
} else {
library(ggridges) }
if (!requireNamespace("gradethis", quietly = TRUE)) {
  learnr::tutorial_warning(
    "This tutorial uses the **gradethis** package to provide feedback.  
    It looks like you don’t have gradethis installed yet.  
    Please run this in your console:
    
    remotes::install_github('rstudio-education/gradethis')"
  )
} else {
  library(gradethis)
  gradethis::gradethis_setup()  # optional: standardizes grading defaults
}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(out.width = '90%')
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
```



```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```


## Introduction
### 

This tutorial covers [Chapter 9: Layers](https://r4ds.hadley.nz/layers.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. You will learn how to use [**ggplot2**](https://ggplot2.tidyverse.org/) and related packages to create persuasive graphics. Key functions include [`geom_smooth()`](https://ggplot2.tidyverse.org/reference/geom_smooth.html),  [`geom_histogram()`](https://ggplot2.tidyverse.org/reference/geom_histogram.html), and  [`facet_wrap()`](https://ggplot2.tidyverse.org/reference/facet_wrap.html).


## Aesthetic mappings
### 

We’ll start with a deeper dive into aesthetic mappings. 

### Exercise 1

Load up the **tidyverse** library.


```{r aesthetic-mappings-1, exercise = TRUE}

```

```{r aesthetic-mappings-1-hint-1, eval = FALSE}
library(___)
```

```{r aesthetic-mappings-1-test, include = FALSE}
library(tidyverse)
```

### 

The `mpg` tibble bundled with the **ggplot2** package contains 234 observations on 38 car models. The key variables for us include:

* **displ**: A car’s engine size, in liters. A numerical variable.

* **hwy**: A car’s fuel efficiency on the highway, in miles per gallon (mpg). A car with a low fuel efficiency consumes more fuel than a car with a high fuel efficiency when they travel the same distance. A numerical variable.

* **class**: Type of car. A categorical variable.


### Exercise 2

We want to visualize the relationship between the car's engine size and fuel efficiency on the highway. 

Create a ggplot with `hwy` plotted against `displ`. 

```{r aesthetic-mappings-5, exercise = TRUE}
ggplot(mpg, aes(___ = displ, 
                ___ = hwy)) +
  ___()
```

```{r aesthetic-mappings-5-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy)) +
  geom_point()
```

### 

A scatter plot like this is the most common way to look at relationships between two continuous variables.

Set the `color` argument within `aes()` to `class`. Each point will have a color based on the `class` of the car.

```{r aesthetic-mappings-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r aesthetic-mappings-6-hint-1, eval = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy, 
                color = ___)) +
  geom_point()
```

```{r aesthetic-mappings-6-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy,
                color = class)) +
  geom_point()
```

### 

The plot is much richer, even though it isn't any larger, because we have used color to incorporate information about the type of car. Notice how the SUVs cluster in the lower right. Their engines are (mostly) bigger, and they all get worse gas mileage.

### 

Replace the `color` argument with the `shape` argument within `aes()`. Set the value to `class`, as before. Each point will have a shape based on the `class` of the car.

```{r aesthetic-mappings-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r aesthetic-mappings-7-hint-1, eval = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy, 
                shape = ___)) +
  geom_point()
```

```{r aesthetic-mappings-7-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy,
                shape = class)) +
  geom_point()
```

###

When class is mapped to shape, we get two warnings:

````
1: The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate; you have 7. Consider specifying shapes manually if you must have them.

2: Removed 62 rows containing missing values (geom_point()).
````


Since `ggplot()` will only use six shapes at a time, by default, additional groups will go unplotted when you use the `shape` aesthetic. The second warning is related – there are 62 SUVs in the dataset and they’re not plotted.

### 

Replace the `shape` argument with the `size` argument within `aes()`. Set the value to `class`, as before. Each point will have a size based on the `class` of the car.

```{r aesthetic-mappings-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r aesthetic-mappings-8-hint-1, eval = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy, 
                size = ___)) +
  geom_point()
```

```{r aesthetic-mappings-8-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy,
                size = class)) +
  geom_point()
```

###

You should see a warning message:

````
Using size for a discrete variable is not advised. 
````

Mapping an unordered discrete (categorical) variable, like `class`, to an ordered aesthetic, like `size` is generally not a good idea because it implies a ranking or ordering that does not exist, hence the warning.

### 

Replace the `size` argument with the `alpha` argument within `aes()`. Set the value to `class`, as before. Each point will have a transparency based on the `class` of the car.

```{r aesthetic-mappings-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r aesthetic-mappings-9-hint-1, eval = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy, 
                alpha = ___)) +
  geom_point()
```

```{r aesthetic-mappings-9-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy,
                alpha = class)) +
  geom_point()
```

You should see a warning message, as above:

````
Using alpha for a discrete variable is not advised. 
````

### 

You can also set the visual properties of your geom manually as an argument of your geom function (outside of `aes()`). Remove the `alpha` argument from your code and add `color = "blue"` **within** the call to `geom_point()`.

```{r aesthetic-mappings-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r aesthetic-mappings-10-hint-1, eval = FALSE}
ggplot(mpg, aes(x = ___, 
                y = hwy)) + 
  geom_point(color = "___")
```

```{r aesthetic-mappings-10-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy)) + 
  geom_point(color = "blue")
```

### 

Here, the color doesn’t convey information about a variable, but only changes the appearance of the plot. You’ll need to pick a value that makes sense for that aesthetic:

* The name of a color as a character string, e.g., color = "blue".
* The size of a point in mm, e.g., size = 1.
* The shape of a point as a number, e.g, shape = 1. [Here is a link](https://r4ds.hadley.nz/layers_files/figure-html/fig-shapes-1.png) to all of the different shapes built in to `ggplot`.

You can learn more about all possible aesthetic mappings in the aesthetic specifications [vignette](https://ggplot2.tidyverse.org/articles/ggplot2-specs.html).

## Geometric objects
### 

To change the geom in your plot, change the geom function that you add to `ggplot()`. Let's start with the plot which we were just working with. Remove `color = "blue"` from the call to `geom_point()`. 

```{r geometric-objects-1, exercise = TRUE}
ggplot(___, aes(x = displ, 
                y = hwy)) + 
  geom_point()
```

```{r geometric-objects-1-hint-1, eval = FALSE}
ggplot(___, aes(x = displ, 
                y = hwy)) + 
  geom_point()
```

```{r geometric-objects-1-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy)) + 
  geom_point()
```

### 

Every geom function in **ggplot2** takes a mapping argument, either defined locally in the geom layer or globally in the `ggplot()` layer. 

Replace `geom_point()` with `geom_smooth()`. Both plots contain the same `x` variable, the same `y` variable, and both describe the same data. But the plots use different geometric objects to represent the data.

```{r geometric-objects-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r geometric-objects-2-hint-1, eval = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy)) + 
  ___()
```

```{r geometric-objects-2-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy)) + 
  geom_smooth()
```

### 

**Not every aesthetic works with every geom**. You could set the shape of a point, but you couldn’t set the “shape” of a line. If you try, **ggplot2** will silently ignore that aesthetic mapping. Compare the two following plots:

```{r linetypes, exercise = TRUE}
ggplot(mpg, aes(x = displ, y = hwy, shape = drv)) + 
  geom_smooth()

ggplot(mpg, aes(x = displ, y = hwy, linetype = drv)) + 
  geom_smooth()
```


###

Note the message which gets displayed when calling `geom_smooth()`.

````
`geom_smooth()` using method = 'loess' and formula = 'y ~ x'
````

`geom_smooth()` is informing us of the values which it is using, by default, for the `method` and `formula` arguments. Add `method = 'loess'` to the `geom_smooth()` call.

```{r geometric-objects-3, exercise = TRUE}
ggplot(mpg, aes(x = displ, 
                y = hwy)) + 
  geom_smooth(___ = 'loess')
```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r geometric-objects-3-hint-1, eval = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy)) + 
  geom_smooth(___ = 'loess')
```

```{r geometric-objects-3-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy)) + 
  geom_smooth(method = 'loess')
```

### 

Note how the message has changed.

````
`geom_smooth()` using formula = 'y ~ x'
````

We don't get a redundant warning after explicitly calling the default method, `loess`. 

### 

Make two more additions to the call to `geom_smooth()`. First, add `formula = 'y ~ x'` to remove the message. Second, add `se = FALSE`. 


```{r geometric-objects-4, exercise = TRUE}
ggplot(mpg, aes(x = displ, 
                y = hwy)) + 
  geom_smooth(method = 'loess', 
              ___ = 'y ~ x',
              se = ___)
```

<button onclick = "transfer_code(this)">Copy previous code</button>


```{r geometric-objects-4-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy)) + 
  geom_smooth(method = 'loess', 
              formula = 'y ~ x',
              se = FALSE)
```

### 

The `se`, which stands for "standard error," determines whether or not error bars around the line are included. By default, the value of `se` is `TRUE`. We set it to `FALSE` here in order to make the graphic less cluttered.


### 

`geom_smooth()` will draw a different line, with a different `linetype`, for each unique value of the variable that you map to `linetype`. Within the call to `aes()`, add `linetype = drv`.

```{r geometric-objects-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r geometric-objects-5-hint-1, eval = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy, 
                linetype = ___)) + 
  geom_smooth(method = 'loess', 
              formula = 'y ~ x',
              se = FALSE)
```

```{r geometric-objects-5-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy, 
                linetype = drv)) + 
  geom_smooth(method = 'loess', 
              formula = 'y ~ x',
              se = FALSE)
```

### 

Here, we mapped the `linetype` into three lines based on the `drv` value, which describes a car’s drive train.

Replace `linetype = drv` with `color = drv` within `aes()`.


```{r geometric-objects-6, exercise = TRUE}
ggplot(mpg, aes(x = displ, 
                y = hwy, 
                ___ = drv)) + 
  geom_smooth(method = 'loess', 
              formula = 'y ~ x',
              se = FALSE)
```

<button onclick = "transfer_code(this)">Copy previous code</button>


```{r geometric-objects-6-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy, 
                color = drv)) + 
  geom_smooth(method = 'loess', 
              formula = 'y ~ x',
              se = FALSE)
```

### 

The `geom_smooth()` geom is applied to each category of color separately. With one call to a geom, we get three different plots, all on the same graph. There are no front-wheel drive cars with a `displ` value greater than 5, so the green line does not extend to the right-side of the graphic. 

### 

We can make our message clearer by overlaying the lines on top of the raw data. To do this, simply add a call to `geom_point()` in between `ggplot()` and `geom_smooth()`. Don't forget to separate different lines with `+`.


```{r geometric-objects-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r geometric-objects-7-hint-1, eval = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy, 
                color = drv)) + 
  ___() +
  geom_smooth(method = 'loess', 
              formula = 'y ~ x',
              se = FALSE)
```

```{r geometric-objects-7-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy, 
                color = drv)) + 
  geom_point() +
  geom_smooth(method = 'loess', 
              formula = 'y ~ x',
              se = FALSE)
```


### 

The `aes()` values cascade across all the geom's, unless and until we change them ourselves. To see this, add `aes(linetype = drv)` to the call to `geom_smooth()`.

```{r geometric-objects-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r geometric-objects-8-hint-1, eval = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy, 
                color = drv)) + 
  ___ +
  geom_smooth(___(linetype = ___))
```

```{r geometric-objects-8-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy, 
                color = drv)) + 
  geom_point() +
  geom_smooth(method = 'loess', 
              formula = 'y ~ x',
              se = FALSE,
              aes(linetype = drv))
```


### 

Many geoms accept an overarching `group` aesthetic, which applies meta-data structure to the data for plotting (like `group_by` in a `dplyr` pipe). However, the group designation maps to aesthetic features differently for different geoms. We have more control if we specify the aesthetics directly.

Examine the three plots below: 


```{r geometric-objects-9, exercise = TRUE}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_smooth()

# Using group
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_smooth(aes(group = drv))

# mapping color explicitly
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_smooth(aes(color = drv))
```

The `group` aesthetic by itself does not add a legend or distinguishing features to the geoms.

###

We have seen previously that the plot changes based on **global** aesthetic mappings (within `ggplot()`) or **local** aesthetic mappings (within specific geoms). 

Here is a global mapping of color to `class`:

```{r geometric-objects-10, exercise = TRUE, warning = FALSE, message = FALSE}
ggplot(mpg, aes(x = displ, y = hwy,color = class)) + 
  geom_point() + 
  geom_smooth()
```

###

Move the `aes` mapping of `color=class` locally to `geom_point`.

```{r geometric-objects-11, exercise = TRUE, warning = FALSE, message = FALSE}
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(___) + 
  geom_smooth()
```

### 

This looks much better - and it also points to a story. The smoothed line shows a quadratic trend where efficiency ticks up after declining over engine size. However, if we examine the different colors for `class`, we see that all vehicles types have a general linear decline in efficiency by size... except 2seaters. 

We can add layers that highlight specific parts of our data by layering geometric objects after applying `filter`. 

Below, we want to specifically draw attention to engine size and efficiency of 2-seater vehicles:

```{r,  geometric-objects-12, exercise = TRUE}
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_point(
    data = mpg |> filter(class == "2seater"), 
    color = "red"
  ) +
  geom_point(
    data = mpg |> filter(class == "2seater"), 
    shape = "circle open", size = 3, color = "red"
  )
```

###

The first `geom_point()` layer plots all the data with default size and black color. 

The second `geom_point()` adds a layer of red dots on top of the black dots for 2 seaters only. 

The third `geom_point()` adds large (size = 3) open circles (shape) in red. 

### 

Geoms are the fundamental building blocks of ggplot2. You can completely transform the look of your plot by changing its geom, and different geoms can reveal different features of your data. 

Here are three ways to examine the same thing: the distribution of `hwy`. 

```{r geometric-objects-15, exercise = TRUE}
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(binwidth = 2)

ggplot(mpg, aes(x = hwy)) +
  geom_boxplot()

ggplot(mpg, aes(x = hwy)) +
  geom_density()
```

### 

The histogram and density highlight the two peaks ("multi-modal distribution"). The boxplot draws attention to the two positive outliers. 


### 

**ggplot2** provides more than 40 geoms but these don’t cover all possible plots one could make. If you need a different geom, look at extension packages first to see if someone else has already implemented it (see https://exts.ggplot2.tidyverse.org/gallery/ for a sampling).

The [**ggridges** package](https://wilkelab.org/ggridges) is useful for making ridgeline plots, which can be useful for visualizing the density of a numerical variable for different levels of a categorical variable. Hit "Run Code" to see an example.

```{r geometric-objects-17, exercise = TRUE}
library(ggridges)

ggplot(mpg, aes(x = hwy, y = drv, fill = drv, color = drv)) +
  geom_density_ridges(alpha = 0.5, show.legend = FALSE)
```

### 

The best place to get a comprehensive overview of all of the geoms **ggplot2** offers, as well as all functions in the package, is the [reference page](https://ggplot2.tidyverse.org/reference). To learn more about any single geom, use the help (e.g., `?geom_smooth`).

## Facets
### 

We've now worked with facets many times. Facets are created with functions like `facet_wrap()` and `facet_grid()`. Facets create copies of the same plot for each value of a third variable.

### 

Start with our usual basic scatter plot, `displ` versus `hwy` from the `mpg` tibble.

```{r facets-1, exercise = TRUE}
ggplot(mpg, aes(x = displ, 
                y = hwy)) + 
  geom_point()
```

### 

Add `facet_wrap(~cyl)` to the end of your plot code.


```{r facets-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r facets-2-hint-1, eval = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy)) + 
  geom_point() + 
  facet_wrap(~ ___)
```

```{r facets-2-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy)) + 
  geom_point() + 
  facet_wrap(~cyl)
```

### 

Here's something new: we can facet our plots with the *combination* of two variables. 

To do this, switch from `facet_wrap()` to `facet_grid()`. The first argument of `facet_grid()` is also a formula, but now it’s a double sided formula: `rows` ~ `cols`. 

Replace `facet_wrap(~cyl)` with `facet_grid(drv ~ cyl)`.


```{r facets-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r facets-3-hint-1, eval = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy)) + 
  geom_point() + 
  facet____(___ ~ cyl)
```

```{r facets-3-test, include = FALSE}
ggplot(mpg, aes(x = displ, 
                y = hwy)) + 
  geom_point() + 
  facet_grid(drv ~ cyl)
```

### 

By default each of the facets share the same scale and range for x and y axes. This is useful when you want to compare data across facets but it can be limiting when you want to visualize the relationship within each facet better. 

Setting the scales argument in a faceting function to "free" will allow for different axis scales across both rows and columns, "free_x" will allow for different scales across rows, and "free_y" will allow for different scales across columns.

Add `scales = "free_y"` to the call to `facet_grid()`. 

```{r facets-4, exercise = TRUE}
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  facet_grid(drv ~ cyl, ___ = ___)
```


## Statistical transformations
### 

Instead of simply plotting data, it is sometimes useful to calculate a statistic based on the data and then plot the value of that statistic.

Consider a basic bar chart for the `diamonds` dataset:

```{r statistical-transformations-4, exercise = TRUE}
diamonds |> 
  ggplot(aes(x = cut)) + 
  geom_bar()
```

### 

On the y-axis, it displays "count", but "count" is not a variable in diamonds! It is a "statistical transformation" which **ggplot2** has calculated for us.

Many graphs, like scatterplots, plot the raw values of your dataset. Other graphs, like bar charts, calculate new values to plot:

* Bar charts, histograms, and frequency polygons bin your data and then plot bin counts, the number of points that fall in each bin.

* Smoothers fit a model to your data and then plot predictions from the model.

* Boxplots compute the five-number summary of the distribution and then display that summary as a specially formatted box.


### 

The algorithm used to calculate new values for a graph is called a "stat," short for statistical transformation. 

Suppose we want to perform our own summary calculations first, then pass them to `ggplot`. Let's look at a frequency table for `cut`:

```{r statistical-transformations-5, exercise = TRUE}
diamonds |>
  count(cut)
```

We can still plot our own summary table, but we need to override the default "stat". We saw this in our Brexit homework!

Pipe the frequency table to ggplot and add `geom_bar(stat = 'identity')` to the pipeline.

```{r statistical-transformations-7, exercise = TRUE}
diamonds |>
  count(cut) |>
  ggplot(aes(x = cut, y = n)) +
  geom_bar(stat = "identity")
```

### 

The result is the same as the much-more-straight-forward usage of `geom_bar()` which we created above.

### 

In our Brexit homework, we manually calculated proportions and plotted those with `stat = "identity"`. There are a few other shortcuts for creating proportions (though we have a little less control). `after_stat` is a `ggplot` shortcut for mapping stats to an aesthetic. You can use `after_stat()` with `prop`, `count`, or `density` in the argument. It's useful in very limited situations.

```{r statistical-transformations-8, exercise = TRUE}
ggplot(diamonds, aes(x = cut, y = after_stat(prop), group = 1)) + 
  geom_bar()
```

###

To find the possible variables that can be computed by the stat, look for the section titled “computed variables” in the [help](https://ggplot2.tidyverse.org/reference/geom_bar.html) for `geom_bar()`.

### 

You might want to draw greater attention to the statistical transformation in your code. For example, you might use `stat_summary()`, which summarizes the y values for each unique x value, to draw attention to the summary that you’re computing.

```{r statistical-transformations-9, exercise = TRUE}
ggplot(diamonds) + 
  stat_summary(
    aes(x = cut, y = depth),
    fun.min = min,
    fun.max = max,
    fun = median
  )
```


### 

**ggplot2** provides more than 20 stats for you to use. Each stat is a function, so you can get help in the usual way, e.g., `?stat_bin`.

## Position adjustments
### 

There’s one more piece of magic associated with bar charts. You can color a bar chart using either the `color` aesthetic, or, more usefully, the `fill` aesthetic.


```{r position-adjustments-1, exercise = TRUE}
ggplot(mpg, aes(x = drv, color = drv)) + 
  geom_bar()

ggplot(mpg, aes(x = drv, fill = drv)) + 
  geom_bar()
```


### 

It may seem strange to use `drv` as the argument to both `x` and to `fill`, but we saw how redundancy can be selectively used in our Brexit activity. 

Here, the two arguments are doing two different things, but both of those things highlight the `drv` variable. 

### 

Change `fill = drv` to `fill = class`.

```{r position-adjustments-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r position-adjustments-3-hint-1, eval = FALSE}
ggplot(mpg, aes(x = drv, fill = ___)) + 
  geom_bar()
```

```{r position-adjustments-3-test, include = FALSE}
ggplot(mpg, aes(x = drv, fill = class)) + 
  geom_bar()
```

### 

Note what happens if you map the fill aesthetic to another variable, like `class`: the bars are automatically stacked. Each colored rectangle represents a combination of `drv` and `class`.

The stacking is performed automatically using the position adjustment specified by the position argument. If you don’t want a stacked bar chart, you can use one of three other options: "identity", "dodge" or "fill". 

The identity position adjustment is more useful for 2d geoms, like points, where it is the default, or in cases where we have already calculated our summary stat.

###

`position = "fill"` works like stacking, but makes each set of stacked bars the same height. It does so by transforming the data to relative proportions.

```{r position-adjustments-6, exercise = TRUE}
ggplot(mpg, aes(x = drv, fill = class)) + 
  geom_bar(position = ___)
```


### 

`position = "dodge"` places overlapping objects directly *beside* one another.  Replace `"fill"` with `"dodge"`. This makes it easier to compare individual values.

```{r position-adjustments-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r position-adjustments-7-hint-1, eval = FALSE}
ggplot(mpg, aes(x = drv, fill = class)) + 
  geom_bar(position = ___)
```

```{r position-adjustments-7-test, include = FALSE}
ggplot(mpg, aes(x = drv, fill = class)) + 
  geom_bar(position = "dodge")
```

### 


There’s one other type of adjustment that’s not useful for bar charts, but can be very useful for scatterplots. Recall our first scatterplot. Did you notice that the plot displays only 126 points, even though there are 234 observations in the dataset? Starting with our usual `ggplot(mpg, aes(x = displ, y = hwy))`, add `geom_point(position = "jitter")`

```{r position-adjustments-8, exercise = TRUE}
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(___ = "jitter")
```

```{r position-adjustments-8-hint-1, eval = FALSE}
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(___ = "jitter")
```

```{r position-adjustments-8-test, include = FALSE}
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(position = "jitter")
```

### 

Adding randomness seems like a strange way to improve your plot, but while it makes your graph less accurate at small scales, it makes your graph more revealing at large scales. 

Because this is such a useful operation, **ggplot2** comes with a shorthand for `geom_point(position = "jitter")`: `geom_jitter()`.

To learn more about a position adjustment, look up the help page associated with each adjustment: `?position_dodge`, `?position_fill`, `?position_identity`, `?position_jitter`, and `?position_stack`.

## Coordinate Systems
### 

Coordinate systems are probably the most complicated part of **ggplot2**. The default coordinate system is the Cartesian coordinate system where the x and y positions act independently to determine the location of each point. 

Hit "Run Code" to create an object with data for New Zealand and then create a plot.

```{r coordinate-systems-2, exercise = TRUE}
nz <- map_data("nz")

ggplot(nz, aes(x = long, y = lat, group = group)) +
  geom_polygon(fill = "white", color = "black")
```

###

`coord_quickmap()` sets the aspect ratio correctly for geographic maps. This is very important if you’re plotting spatial data with **ggplot2**. 

```{r coordinate-systems-3, exercise = TRUE}
nz <- map_data("nz")
ggplot(nz, aes(x = long, y = lat, group = group)) +
  geom_polygon(fill = "white", color = "black") +
  coord_quickmap()
```

### 

We don’t have the space to discuss maps extensively in this tutorial but you can learn more in the [Maps](https://ggplot2-book.org/maps) chapter of [*ggplot2: Elegant Graphics for Data Analysis*](https://ggplot2-book.org/). 

### 

A shortcut to flip the location of your x and y axes is `coord_flip()`. 

```{r coordinate-systems-4, exercise = TRUE}
ggplot(data = diamonds) + 
  geom_bar(
    mapping = aes(x = clarity, fill = clarity))

ggplot(data = diamonds) + 
  geom_bar(
    mapping = aes(x = clarity, fill = clarity)) +
  coord_flip()

## same as 
ggplot(data = diamonds) + 
  geom_bar(
    mapping = aes(y = clarity, fill = clarity))

```

### 

`coord_polar()` uses polar coordinates rather than x-y coordinates. We sometimes see these in network analyses.

```{r coordinate-systems-5, exercise = TRUE}
ggplot(data = diamonds) + 
  geom_bar(
    mapping = aes(x = clarity, fill = clarity)) +
  coord_polar()
```


## The layered grammar of graphics
### 

Consider this overview:

````
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(
     mapping = aes(<MAPPINGS>),
     stat = <STAT>, 
     position = <POSITION>
  ) +
  <COORDINATE_FUNCTION> +
  <FACET_FUNCTION>
````

This template takes seven parameters, adding on to what we learned in chapter 1 of R4DS.The seven parameters in the template compose the grammar of graphics, a formal system for building plots. The [grammar of graphics](https://vita.had.co.nz/papers/layered-grammar.pdf) is based on the insight that you can uniquely describe any plot as a combination of a dataset, a geom, a set of mappings, a stat, a position adjustment, a coordinate system, a faceting scheme, and a theme.

In practice, you rarely need to supply all seven parameters to make a graph because `ggplot2` will provide useful defaults for everything except the data, the mappings, and the geom function.


```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
